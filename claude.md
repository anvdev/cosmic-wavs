# Creating WAVS components

You started a new job at Layer Labs. Your task is to create new components that run using WAVS, a WASI runtime for AVSs. Read this guide carefully, as it will orient you on how to build services. The repo you are in is a foundry template with an existing example in components/eth-price-oracle/. This repo uses a makefile to streamline commands.

## Commands

The only two commands you will need to test if you made a component correctly are:

1. `make wasi-build`: builds every component in the /component directory, generates bindings automatically (you do not ever need to write or edit a bindings.rs file!), compiles components to wasm, and places them in the /compiled folder. component `/eth-price-oracle` becomes `eth_price_oracle.wasm`

2. Use the following command to test the component:

```bash
# Choose the appropriate format for your component's input data:
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # For strings (with null byte padding up to 32 bytes)
# Or use other formats based on your needs:
# export TRIGGER_DATA_INPUT=`cast abi-encode "f(uint256)" 123456` # For numeric inputs
# export TRIGGER_DATA_INPUT=`cast abi-encode "f((uint256,string))" 123 "example"` # For struct inputs
# export TRIGGER_DATA_INPUT="0x1234abcd" # For raw hex data

export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[],\"kv\":[],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # The service config
make wasi-exec
```

## Environment variables

You can set public and private variables in components.
1. public
   - set in `SERVICE_CONFIG` `kv` array
2. private
   - set in `SERVICE_CONFIG` `host_envs` array
   - MUST be prefixed with `WAVS_ENV_`
   - This variable is set in the .env file in the root of this repo. Use the following steps:
     1. see if `.env` exists: `ls -la .env`
     - If there is no .env file, use `cp .env.example .env`.
     1. Add your private variable:
```bash
sed -i '' '1i\
WAVS_ENV_MY_API_KEY=your_secret_key_here
' .env
```

Use in component:

```rust
let endpoint = std::env::var("api_endpoint")?;
let api_key = std::env::var("WAVS_ENV_MY_API_KEY")?;
```

### IMPORTANT: Always store API keys in environment variables

For security reasons, you should NEVER hardcode API keys directly in your component code. Always store API keys and other sensitive credentials as environment variables using the method above. 

Example of correct and secure API key usage:
```rust
// CORRECT: Getting API key from environment variable
let api_key = std::env::var("WAVS_ENV_OPENWEATHER_API_KEY")
    .map_err(|e| format!("Failed to get API key: {}", e))?;
let url = format!(
    "https://api.example.com/endpoint?api_key={}", 
    api_key
);

// INCORRECT: Hardcoding API key (never do this!)
// let api_key = "1234567890abcdef"; // SECURITY RISK!
```

This approach ensures your sensitive credentials are not committed to version control and can be managed securely.

Set with command
```bash
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # your input data for testing the component. Make sure this is formatted correctly for your component.
export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[\"WAVS_ENV_MY_API_KEY\"],\"kv\":[[\"api_endpoint\",\"https://api.example.com\"]],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # public variable set in kv.
make wasi-exec
```

## Foundry Template structure

The foundry template is made up of the following main files:

```bash
wavs-foundry-template/
├── README.md
├── makefile               # Commands, variables, and configs
├── components/            # WASI components
│   └── eth-price-oracle/
│       ├── Cargo.toml     # Component dependencies
│       ├── lib.rs         # Main Component logic
│       ├── trigger.rs     # Trigger handling
│       └── bindings.rs    # Bindings generated by `make build`
├── compiled/              # WASM files compiled by `make build`
├── src/
│   ├── contracts/        # Trigger and submission contracts
│   └── interfaces/       # Solidity interfaces
├── script/               # Scripts used in makefile commands
├── cli.toml              # CLI configuration
├── wavs.toml             # WAVS service configuration
├── docs/                 # Documentation
└── .env                  # Private environment variables
```

- The `README` file contains the tutorial commands.
- The `makefile` contains commands for building and deploying the service. It also contains variables and configs for the service.
- The components directory contains the component logic for your service. Running `make wasi-build` will automatically generate bindings and compile components into the `compiled` directory.
- The src directory contains the Solidity contract and interfaces.
- The script directory contains the scripts used in the makefile commands to deploy, trigger, and test the service.
- The `.env` file contains private environment variables and keys. Use `cp .env.example .env` to copy the example `.env` file.

## WAVS services

The basic service is made up of a trigger, a component, and submission logic (optional).

[Trigger](#triggers): any onchain event emitted from a contract.

[Component](#components): the main logic of a WAVS service. Components are responsible for processing the trigger data and executing the business logic.

[Submission](#submission): handles the logic for submitting a component's output to the blockchain.

## Triggers

A trigger prompts a WAVS service to run. Operators listen for the trigger event specified by the service and execute the corresponding component off-chain. Triggers can be any onchain event emitted from any contract.

### Trigger lifecycle

1. When a service is deployed, it is configured with a trigger address and event, a wasi component, and a submission contract (optional).

2. Registered operators listen to chain logs. Each operator maintains lookup maps and verifies events against registered triggers.

3. When a trigger event is emitted, operators pick up the event and verify the event matches the registered trigger.

4. If a match is found, WAVS creates a `TriggerAction` that wraps the trigger event data:

```rust
TriggerAction {
    // Service and workflow identification
    config: TriggerConfig {
       service_id: ServiceID,      // Generated during deployment
        workflow_id: WorkflowID,    // Default or specified
        trigger: Trigger::EthContractEvent {
           address: Address,       // Contract address
            chain_name: ChainName,  // Chain identifier
            event_hash: ByteArray<32> // Event signature
        }
    },
   // The actual event data
    data: TriggerData::EthContractEvent {
        contract_address: Address,  // Emitting contract
        chain_name: ChainName,      // Source chain
        log: LogData {             // Raw event data
            topics: Vec<Vec<u8>>,  // Event signature + indexed params
            data: Vec<u8>         // ABI-encoded event data
        },
        block_height: u64         // Block number
    }
}
```

5. The TriggerAction is converted to a WASI-compatible format and passed to the component where it is decoded and processed.

### Developing triggers

WAVS doesn't interpret the contents of event triggers. Instead, it passes the raw log data to components, which can decode and process the data according to their specific needs.

## Components

WASI components contain the main logic of a WAVS service. They are responsible for processing the trigger data and executing the business logic of a service.

A basic component has three main parts:

- Decoding incoming trigger data.
- Processing the data (this is the custom logic of your component).
- Encoding and returning the result for submission (if applicable).

After being passed the `TriggerAction`, the component decodes it using the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate.

```rust
#[allow(warnings)]
mod bindings;
use alloy_sol_types::{sol, SolValue};
use bindings::{export, wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent}, Guest, TriggerAction};
use wavs_wasi_chain::decode_event_log_data;

// Solidity types for the incoming trigger event using the `sol!` macro
sol! {
    event MyEvent(uint64 indexed triggerId, bytes data);
    struct MyResult {
        uint64 triggerId;
        bool success;
    }
}

// Define the component
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
        match action.data {
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // 1. Decode the event (always clone log to avoid ownership issues)
                let log_clone = log.clone();
                let event: MyEvent = decode_event_log_data!(log_clone)
                    .map_err(|e| format!("Failed to decode event: {}", e))?;
                
                // 2. Process data (your business logic goes here)
                let result = MyResult {
                    triggerId: event.triggerId, // Use the triggerId from the decoded event
                    success: true
                };
                
                // 3. Return encoded result
                Ok(Some(result.abi_encode()))
            }
            _ => Err("Unsupported trigger type".to_string())
        }
    }
}
```

Components must implement the `Guest` trait, which is the main interface between your component and the WAVS runtime. The `run` function is the entry point for processing triggers: it should receive the trigger data, decode it, process it according to your component's logic, and return the results. If you need to submit results to the blockchain, results need to be encoded using `abi_encode()`.

The `sol!` macro from `alloy_sol_types` is used to define Solidity types in Rust. It generates Rust structs and implementations that match your Solidity types, including ABI encoding/decoding methods.

Bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

## Common Type and Data Handling Issues

When building components, you'll need to handle several common issues:

### 1. Rust-Solidity Type Conversions

Solidity and Rust have different type systems. For numeric types:

```rust
// String parsing method - works reliably for all numeric types 
let temperature: u128 = 29300;
let temperature_uint256 = temperature.to_string().parse().unwrap();

// Only use .into() for simple types where supported
let small_value: u8 = 42;
let small_value_uint = small_value.into(); // Works for some cases
```

### 2. Binary Data Handling

When working with Solidity structs that contain binary data:

```rust
// Always convert Vec<u8> to Bytes explicitly for Solidity data fields
let data_with_id = solidity::DataWithId {
    triggerId: trigger_id,
    data: Bytes::from(result.abi_encode()), // Convert Vec<u8> to Bytes
};
```

### 3. String Input Processing

When using string inputs via format-bytes32-string:

```rust
// 1. Always clone before using String::from_utf8 to avoid ownership errors
let input_string = String::from_utf8(trigger_data.clone())?;

// 2. Always trim null bytes added by format-bytes32-string
let clean_input = input_string.trim_end_matches('\0');

// Now safe to use in URLs or other contexts
let url = format!("https://api.example.com/endpoint?param={}", clean_input);
```

### 4. Event Log Decoding

When using the decode_event_log_data! macro:

```rust
// Always clone the log before decoding to avoid ownership errors
let log_clone = log.clone();
let event: MyEvent = decode_event_log_data!(log_clone)?;
```

## Input and Output Handling

Components can receive trigger data in two ways:

1. Via an onchain event (after deployment)
2. Via the `wasi-exec` command (for testing)

### Input Data Formatting for Testing

When testing with `make wasi-exec`, format input data appropriately:

1. **String inputs**:
   ```bash
   export TRIGGER_DATA_INPUT=`cast format-bytes32-string "90210"` # For zip codes, strings, etc.
   ```

2. **Numeric inputs**:
   ```bash
   export TRIGGER_DATA_INPUT=`cast abi-encode "f(uint256)" 123456` # For uint256 values
   ```

3. **Custom struct inputs**:
   ```bash
   export TRIGGER_DATA_INPUT=`cast abi-encode "f((uint256,string))" 123 "example"` # For structs
   ```

4. **Raw hex data**:
   ```bash
   export TRIGGER_DATA_INPUT="0x1234abcd" # For custom binary formats
   ```

## Network Requests

Components can make HTTP requests using the `wavs-wasi-chain` crate and `block_on` for async handling:

```rust
use wstd::runtime::block_on;  // Required for running async code

// The request function must be async
async fn make_request() -> Result<ResponseType, String> {
    let url = "https://api.example.com/endpoint";
    let req = http_request_get(&url)?;
    
    // Parse JSON response
    let response: ResponseType = fetch_json(req).await?;
    Ok(response)
}

// Use block_on in the main component logic
fn process_data() -> Result<ResponseType, String> {
    block_on(async { make_request().await })
}
```

## Best Practices

To build reliable components:

### Key Development Tips

1. **Clone data when needed**: Always clone data before passing to consuming functions like String::from_utf8()
2. **Handle string input**: Always trim null bytes from format-bytes32-string inputs with trim_end_matches('\0')
3. **Use reliable type conversions**: Prefer string parsing method for numeric conversions to Solidity types
4. **Clone logs before decoding**: Always use log.clone() before passing to decode_event_log_data!
5. **Proper error handling**: Use detailed error messages and proper error propagation

### Development Process

1. Build and test incrementally
2. Validate each step with println!() statements during development
3. Always run `make wasi-build` after making changes to regenerate bindings
4. Test with expected formatting (string inputs, numeric inputs, etc.)
5. Remove debug statements before production

### Pre-Deployment Checklist

- Verify all type conversions are handled correctly
- Confirm proper error handling throughout
- Test with actual input formats to verify handling
- Ensure all sensitive data is in environment variables
- Validate output format matches expected contract format

## Troubleshooting Common Errors

| Error Type | Symptom | Solution |
|------------|---------|----------|
| Type Conversion | "expected Uint<256, 4>, found u128" | Use string parsing: `value.to_string().parse().unwrap()` |
| Binary Type Mismatch | "expected Bytes, found Vec<u8>" | Explicitly convert: `Bytes::from(data)` |
| Event Decoding | "cannot move out of log.data" | Clone before decoding: `let log_clone = log.clone()` |
| String Handling | URL formatting errors | Trim null bytes: `string.trim_end_matches('\0')` |
| Ownership Issues | "use of moved value" | Clone data: `data.clone()` before moving |
| Dependency Issues | "unresolved module" | Use correct import path from wavs_wasi_chain |

For more details on specific topics, refer to the [wavs-wasi-chain documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).