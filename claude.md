# Creating WAVS components

You started a new job at Layer Labs. Your task is to create new components that run using WAVS, a WASI runtime for AVSs. Read this guide carefully, as it will orient you on how to build services. The repo you are in is a foundry template with an existing example in components/eth-price-oracle/. This repo uses a makefile to streamline commands.

## Commands

The only two commands you will need to test if you made a component correctly are:

1. `make wasi-build`: builds every component in the /component directory, generates bindings automatically (you do not ever need to write or edit a bindings.rs file!), compiles components to wasm, and places them in the /compiled folder. component `/eth-price-oracle` becomes `eth_price_oracle.wasm`

2. Use the following command to test the component:

```bash
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # your input data for testing the component. Make sure this is formatted correctly for your component.
export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[],\"kv\":[],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # The service config
make wasi-exec
```

## Environment variables

You can set public and private variables in components.
1. public
   - set in `SERVICE_CONFIG` `kv` array
2. private
   - set in `SERVICE_CONFIG` `host_envs` array
   - MUST be prefixed with `WAVS_ENV_`
   - This variable is set in the .env file in the root of this repo. Use the following steps:
     1. see if `.env` exists: `ls -la .env`
     - If there is no .env file, use `cp .env.example .env`.
     1. Add your private variable:
```bash
sed -i '' '1i\
WAVS_ENV_MY_API_KEY=your_secret_key_here
' .env
```

Use in component:

```rust
let endpoint = std::env::var("api_endpoint")?;
let api_key = std::env::var("WAVS_ENV_MY_API_KEY")?;
```

Set with command
```bash
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # your input data for testing the component. Make sure this is formatted correctly for your component.
export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[\"WAVS_ENV_MY_API_KEY\"],\"kv\":[[\"api_endpoint\",\"https://api.example.com\"]],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # public variable set in kv.
make wasi-exec
```

## Foundry Template structure

The foundry template is made up of the following main files:

```bash
wavs-foundry-template/
├── README.md
├── makefile               # Commands, variables, and configs
├── components/            # WASI components
│   └── eth-price-oracle/
│       ├── Cargo.toml     # Component dependencies
│       ├── lib.rs         # Main Component logic
│       ├── trigger.rs     # Trigger handling
│       └── bindings.rs    # Bindings generated by `make build`
├── compiled/              # WASM files compiled by `make build`
├── src/
│   ├── contracts/        # Trigger and submission contracts
│   └── interfaces/       # Solidity interfaces
├── script/               # Scripts used in makefile commands
├── cli.toml              # CLI configuration
├── wavs.toml             # WAVS service configuration
├── docs/                 # Documentation
└── .env                  # Private environment variables
```

- The `README` file contains the tutorial commands.
- The `makefile` contains commands for building and deploying the service. It also contains variables and configs for the service.
- The components directory contains the component logic for your service. Running `make wasi-build` will automatically generate bindings and compile components into the `compiled` directory.
- The src directory contains the Solidity contract and interfaces.
- The script directory contains the scripts used in the makefile commands to deploy, trigger, and test the service.
- The `.env` file contains private environment variables and keys. Use `cp .env.example .env` to copy the example `.env` file.

## WAVS services

The basic service is made up of a trigger, a component, and submission logic (optional).

[Trigger](#triggers): any onchain event emitted from a contract.

[Component](#components): the main logic of a WAVS service. Components are responsible for processing the trigger data and executing the business logic.

[Submission](#submission): handles the logic for submitting a component's output to the blockchain.

## Triggers

A trigger prompts a WAVS service to run. Operators listen for the trigger event specified by the service and execute the corresponding component off-chain. Triggers can be any onchain event emitted from any contract.

### Trigger lifecycle

1. When a service is deployed, it is configured with a trigger address and event, a wasi component, and a submission contract (optional).

2. Registered operators listen to chain logs. Each operator maintains lookup maps and verifies events against registered triggers.

3. When a trigger event is emitted, operators pick up the event and verify the event matches the registered trigger.

4. If a match is found, WAVS creates a `TriggerAction` that wraps the trigger event data:

```rust
TriggerAction {
    // Service and workflow identification
    config: TriggerConfig {
       service_id: ServiceID,      // Generated during deployment
        workflow_id: WorkflowID,    // Default or specified
        trigger: Trigger::EthContractEvent {
           address: Address,       // Contract address
            chain_name: ChainName,  // Chain identifier
            event_hash: ByteArray<32> // Event signature
        }
    },
   // The actual event data
    data: TriggerData::EthContractEvent {
        contract_address: Address,  // Emitting contract
        chain_name: ChainName,      // Source chain
        log: LogData {             // Raw event data
            topics: Vec<Vec<u8>>,  // Event signature + indexed params
            data: Vec<u8>         // ABI-encoded event data
        },
        block_height: u64         // Block number
    }
}
```

5. The TriggerAction is converted to a WASI-compatible format and passed to the component where it is decoded and processed.

### Developing triggers

WAVS doesn't interpret the contents of event triggers. Instead, it passes the raw log data to components, which can decode and process the data according to their specific needs.

## Components

WASI components contain the main logic of a WAVS service. They are responsible for processing the trigger data and executing the business logic of a service.

A basic component has three main parts:

- Decoding incoming trigger data.
- Processing the data (this is the custom logic of your component).
- Encoding and returning the result for submission (if applicable).

After being passed the `TriggerAction`, the component decodes it using the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate.

```rust

#[allow(warnings)]
mod bindings;
use alloy_sol_types::{sol, SolValue};
use bindings::{export, wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent}, Guest, TriggerAction};
use wavs_wasi_chain::decode_event_log_data;

// Solidity types for the incoming trigger event using the `sol!` macro
sol! {
    event MyEvent(uint64 indexed triggerId, bytes data);
    struct MyResult {
        uint64 triggerId;
        bool success;
    }
}

// Define the component
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
        match action.data {
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // 1. Decode the event
                let event: MyEvent = decode_event_log_data!(log)
                    .map_err(|e| format!("Failed to decode event: {}", e))?;
                
                // 2. Process data (your business logic goes here)
                let result = MyResult {
                    triggerId,
                    success: true
                };
                
                // 3. Return encoded result
                Ok(Some(result.abi_encode()))
            }
            _ => Err("Unsupported trigger type".to_string())
        }
    }
}
```

Components must implement the `Guest` trait, which is the main interface between your component and the WAVS runtime. The `run` function is the entry point for processing triggers: it should receive the trigger data, decode it, process it according to your component's logic, and return the results. If you need to submit results to the blockchain, results need to be encoded using `abi_encode()`.

The `sol!` macro from `alloy_sol_types` is used to define Solidity types in Rust. It generates Rust structs and implementations that match your Solidity types, including ABI encoding/decoding methods.

Bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

## Common Solidity-Rust Type Issues

When working with Solidity types in Rust components, there are several common issues you might encounter:

### Type Conversion and Compatibility

Solidity and Rust have different type systems that require careful handling:

```rust
// WRONG: This will cause compilation errors
sol! {
    struct MyResult {
        uint256 value;
    }
}
// Later in code:
let result = MyResult {
    value: my_u32_value, // Error: expected Uint<256, 4>, found u32
};

// CORRECT: Use proper conversions
sol! {
    struct MyResult {
        uint256 value;
    }
}
// Later in code:
// Option 1: Parse from string
let value_str = my_u32_value.to_string();
let result = MyResult {
    value: value_str.parse().unwrap(), // Convert to Uint<256, 4>
};

// Option 2: Use from() when supported
let result = MyResult {
    value: my_u32_value.into(), // Works only for types that implement From
};
```

### Working with Binary Data

When handling raw binary data from triggers:

```rust
// WRONG: Accessing data incorrectly
TriggerData::Raw(data) => Ok(Some((0, data.0.to_vec(), Destination::CliOutput))),

// CORRECT: Access raw data properly
TriggerData::Raw(data) => Ok(Some((0, data.to_vec(), Destination::CliOutput))),
```

### String Format in sol! Macro

The `sol!` macro can be picky about string formatting:

```rust
// WRONG: Using raw string literals with newlines can cause issues
sol!(r#"
    event NewTrigger(bytes data);
"#);

// CORRECT: Use curly braces for multi-line definitions
sol! {
    event NewTrigger(bytes data);
}
```

### Generic Bytes Handling Pattern

A common pattern for safely handling bytes data:

```rust
// Extract data from trigger bytes 
let data_string = String::from_utf8(trigger_data)
    .map_err(|e| format!("Failed to parse data: {}", e))?;
```

## Submission

A service handler or submission contract handles the logic for submitting a component's output to the blockchain. A submission contract must implement the `handleSignedData()` function using the `IWavsServiceHandler` interface. This interface is defined in the `@wavs` package: https://www.npmjs.com/package/@wavs/solidity?activeTab=code

In the template, the [submission contract](https://github.com/Lay3rLabs/wavs-foundry-template/tree/v0.3.0/src/contracts/WavsSubmit.sol) uses the `handleSignedData()` function to validate the operator's signature and store the processed data from the component. The `DataWithId` struct must match the output format from the component. Each trigger has a unique ID that links the data to its source.

Template submission example:

```solidity
function handleSignedData(bytes calldata _data, bytes calldata _signature) external {
    // 1. Validate the operator's signature by calling the `validate` function on the `_serviceManager` contract
    _serviceManager.validate(_data, _signature);

    // 2. Decode the data into a DataWithId struct defined in the `ITypes` interface
    DataWithId memory dataWithId = abi.decode(_data, (DataWithId));

    // 3. Store the result in state
    _signatures[dataWithId.triggerId] = _signature;      // 1. Store operator signature
    _datas[dataWithId.triggerId] = dataWithId.data;      // 2. Store the data
    _validTriggers[dataWithId.triggerId] = true;         // 3. Mark trigger as valid
}
```

Note: submission contracts are not required for a WAVS service. If you don't need to submit data back to the blockchain, you can modify the makefile `deploy-service` command to use the `--submit none` flag when deploying the service:

```bash
deploy-service:
	@$(WAVS_CMD) deploy-service --log-level=info --data /data/.docker --home /data \
	--component "/data/compiled/${COMPONENT_FILENAME}" \
	--trigger-event-name "${TRIGGER_EVENT}" \
	--trigger-address "${SERVICE_TRIGGER_ADDR}" \
	--service-config ${SERVICE_CONFIG} \
  --submit none
```

## Toml files

There are several toml files in the template that are used to configure the service:

- `wavs.toml` is used to configure the WAVS service itself, including chain configurations (local, testnets, mainnet) and maximum WASM fuel limits.
- `cli.toml` is used to configure the WAVS CLI tool, and also includes chain configurations (local, testnets, mainnet), maximum WASM fuel limits, and log levels.
- `Cargo.toml` in the root directory is used to configure the workspace and includes dependencies, build settings, and component metadata.
- `/components/*/Cargo.toml` in each component directory is used to configure the Rust component and includes dependencies, build settings, and component metadata. It can inherit dependencies from the root `Cargo.toml` file using `workspace = true`.

These files can be customized to suit your specific needs, and many settings can be overridden using environment variables.

The following is an example of a component's `Cargo.toml` file structure:

```toml
# Package metadata - inherits most values from workspace configuration
[package]
name = "eth-price-oracle"        # Name of the component
edition.workspace = true         # Rust edition (inherited from workspace)
version.workspace = true         # Version (inherited from workspace)
authors.workspace = true         # Authors (inherited from workspace)
rust-version.workspace = true    # Minimum Rust version (inherited from workspace)
repository.workspace = true      # Repository URL (inherited from workspace)

# Component dependencies
[dependencies]
# Core dependencies
wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality
# Helpful dependencies
serde = { workspace = true }            # For serialization (if working with JSON)
serde_json = { workspace = true }       # For JSON handling
alloy-sol-macro = { workspace = true }  # For Ethereum contract interactions
wstd = { workspace = true }             # For WASI standard library features
alloy-sol-types = { workspace = true }  # For Ethereum ABI handling
anyhow = { workspace = true }           # For enhanced error handling

# Library configuration
[lib]
crate-type = ["cdylib"]  # Specifies this is a dynamic library crate

# Release build optimization settings
[profile.release]
codegen-units = 1        # Single codegen unit for better optimization
opt-level = "s"          # Optimize for size
debug = false            # Disable debug information
strip = true            # Strip symbols from binary
lto = true              # Enable link-time optimization

# WAVS component metadata
[package.metadata.component]
package = "component:eth-price-oracle"  # Component package name
target = "wavs:worker/layer-trigger-world@0.3.0"  # Target WAVS world and version
```

## Input and Output

When building WASI components, keep in mind that the component can receive the trigger data in two ways:

1. Triggered by an onchain event from a contract after service deployment. Components receive a `TriggerAction` containing event data which is then decoded.

2. Manually via the `wasi-exec` command. The wasi-exec command simulates an onchain event and passes the trigger data directly to the component as `trigger::raw`. No abi decoding is required, and the output is returned as raw bytes.
    - In the `ETH_PRICE_ORACLE` component, the input data needs to be formatted into a `bytes32` string using the `cast format-bytes32-string` when using the `make wasi-exec` command. When creating your own components, use an appropriate format for your use case to use the `wasi-exec` command.

### Data Processing Pattern

The example below shows a basic generic pattern for processing input data and returning output. In the example, the `sol!` macro generates Rust types from Solidity definitions, adds ABI encoding/decoding methods, and handles type conversions (e.g., `uint64` → `u64`). ABI encoding/decoding converts Rust structs to bytes and vice versa. The `decode_event_log_data!` macro decodes the raw event log data and returns a Rust struct matching your Solidity event. This is used for on-chain events.


```rust
// 1. Define your Solidity types using the `sol!` macro
sol! {
    event MyEvent(uint64 indexed triggerId, bytes data);
    struct MyResult {
        uint64 triggerId;
        bytes processedData;
    }
}

// 2. Handle on-chain event trigger and raw trigger types
impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {
        match action.data {
            // On-chain event handling
            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
                // Decode the event
                let event: MyEvent = decode_event_log_data!(log)?;
                
                // Process the data
                let result = MyResult {
                    triggerId: event.triggerId,
                    processedData: process_data(&event.data)?,
                };
                
                // Encode for submission
                Ok(Some(result.abi_encode()))
            }
            // Manual trigger handling for testing
            TriggerData::Raw(data) => {
                // Process raw data directly
                let result = process_data(&data)?;
                Ok(Some(result))
            }
            _ => Err("Unsupported trigger type".to_string())
        }
    }
}
```

In the template, encoding and decoding is handled in the `trigger.rs` file using a `Destination` enum to determine how to process and return data based on the trigger source. The `decode_trigger_event` function in `trigger.rs` determines the destination:

- For `TriggerData::EthContractEvent`, it returns `Destination::Ethereum`
- For `TriggerData::Raw` (used in testing), it returns `Destination::CliOutput`

This allows the component to handle both production and testing scenarios appropriately.

## Logging

Components can use logging to debug and track the execution of the component.

**Logging in development**:

Use `println!()` to write to stdout/stderr. This is visible when running `wasi-exec` locally.

```rust lib.rs
println!("Debug message: {:?}", data);
```

**Logging in production**

For production, you can use a `host::log()` function which takes a `LogLevel` and writes its output via the tracing mechanism. Along with the string that the developer provides, it attaches additional context such as the `ServiceID`, `WorkflowID`, and component `Digest`.

```rust lib.rs
host::log(LogLevel::Info, "Production logging message");
```

## Troubleshooting Components

### Common Error Patterns and Solutions

1. **Binding Generation Issues**:
   - **Symptom**: Errors about missing or incorrect bindings.
   - **Solution**: Run `make wasi-build` to regenerate bindings before testing components.

2. **Type Conversion Errors**:
   - **Symptom**: "Expected X, found Y" compiler errors.
   - **Solution**: Use proper type conversion methods or string-parsing techniques.

3. **Dependency Issues**:
   - **Symptom**: Missing crates or features.
   - **Solution**: Ensure your component's Cargo.toml includes all required dependencies.

4. **Permission Issues with Docker**:
   - **Symptom**: "Permission denied" errors when running commands.
   - **Solution**: Have the operator run the command manually.

### Debugging Tools

1. **Local Execution Logging**:
   - Use `println!()` statements liberally during development.
   - Add context to logged values: `println!("Decoding data: {:?}", data);`

2. **Data Format Verification**:
   - When working with external APIs, log both request URLs and responses.
   - For Ethereum data, use explicit hex formatting for clarity.

3. **Step-by-Step Execution**:
   - Break complex operations into smaller parts with logging between steps.
   - Verify data format at each transformation point.

```rust
// Example of debugging with step validation
println!("Received trigger data: {:?}", trigger_data);
let zip_code = String::from_utf8(trigger_data).expect("Failed to parse zip code");
println!("Decoded zip code: {}", zip_code);

// Verify API key access
match env::var("WAVS_ENV_API_KEY") {
    Ok(key) => println!("API key available, length: {}", key.len()),
    Err(e) => println!("API key error: {}", e),
}
```

## Helpers and utilities

### `wavs-wasi-chain` crate

The `wavs-wasi-chain` crate provides a set of helpful functions for making HTTP requests and interacting with the blockchain. It also provides a macro for decoding trigger data for use in the component.

Learn more in the [crate documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).

### Sol! macro

The `sol!` macro from `alloy-sol-macro` allows you to generate Rust types from Solidity interface files. This is useful for handling blockchain events and data structures in components.


You can write Solidity definitions (interfaces, structs, enums, custom errors, events, and function signatures) directly inside the `sol! { ... }` macro invocation in your Rust code.

At compile time, the `sol!` macro parses that Solidity syntax and automatically generates the equivalent Rust types, structs, enums, and associated functions (like `abi_encode()` for calls or `abi_decode()` for return data/events) needed to interact with smart contracts based on those definitions.

Required Dependencies:

```toml
[dependencies]
alloy-sol-macro = { workspace = true }  # For Solidity type generation
alloy-sol-types = { workspace = true }  # For ABI handling
```

Basic Pattern:

```rust
mod solidity {
    use alloy_sol_macro::sol;
    
    // Generate types from Solidity file
    sol!("../../src/interfaces/ITypes.sol");
    
    // Or define types inline
    sol! {
        struct TriggerInfo {
            uint64 triggerId;
            bytes data;
        }
        
        event NewTrigger(TriggerInfo _triggerInfo);
    }
}
```

In the template, the `sol!` macro is used in the `trigger.rs` component file to generate Rust types from the `ITypes.sol` file.

```rust trigger.rs
mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // The objects here will be generated automatically into Rust types.
    // If you update the .sol file, you must re-run `cargo build` to see the changes.
    sol!("../../src/interfaces/ITypes.sol");
}
```

The macro reads a Solidity interface file and generates corresponding Rust types and encoding/decoding functions. In the example above, it reads `ITypes.sol` which defines:
- `NewTrigger` event
- `TriggerInfo` struct
- `DataWithId` struct

More documentation on the `sol!` macro can be found at: https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html

## Network requests

Components can make network requests to external APIs using the `wavs-wasi-chain` crate. Since WASI components run in a synchronous environment but network requests are asynchronous, you can use `block_on` from the `wstd` crate to bridge this gap. The `block_on` function allows you to run async code within a synchronous context, which is essential for making HTTP requests in WAVS components.

To learn how to use private environment variables like API keys in a component, see the [Private Variables](#private-variables-host_envs) section.

The following dependencies are useful for making HTTP requests from a component. These are added to a component's `Cargo.toml` file:

```toml Cargo.toml
[dependencies]
wavs-wasi-chain = { workspace = true }  # HTTP utilities
wstd = { workspace = true }             # Runtime utilities (includes block_on)
serde = { workspace = true }            # Serialization
serde_json = { workspace = true }       # JSON handling
```

The following example shows how to make a basic HTTP GET request from a component:

```rust lib.rs
use wstd::runtime::block_on;  // Required for running async code

// Async function for the HTTP request
async fn make_request() -> Result<YourResponseType, String> {
    // Create the request
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    
    // Add headers
    req.headers_mut().insert(
        "Accept",
        HeaderValue::from_static("application/json")
    );
    
    // Make the request and parse JSON response
    let json: YourResponseType = fetch_json(req)
        .await
        .map_err(|e| e.to_string())?;
        
    Ok(json)
}

// Main component logic that uses block_on
fn process_data() -> Result<YourResponseType, String> {
    // Use block_on to run the async function
    block_on(async move {
        make_request().await
    })?
}
```

For making POST requests with JSON data, you can use the [`http_request_post_json` helper function](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/http/fn.http_request_post_json.html), which automatically handles JSON serialization and sets header to `application/json`:

```rust lib.rs
async fn make_post_request() -> Result<PostResponse, String> {
    let url = "https://api.example.com/endpoint"; // The URL of the endpoint to make the request to
    let post_data = ("key1", "value1"); // any serializable data can be passed in
    
    // Make POST request and parse JSON response
    let response: PostResponse = fetch_json(
        http_request_post_json(&url, &post_data)?
    ).await.map_err(|e| e.to_string())?;
    
    Ok(response)
}

// Main component logic that uses block_on
fn process_data() -> Result<PostResponse, String> {
    // Use block_on to run the async function
    block_on(async move {
        make_post_request().await
    })?
}
```

Other functions are available in the [crate documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions).

## Blockchain interactions

Interacting with blockchains like Ethereum requires specific dependencies and setup within your component.

### Dependencies

The following dependencies are commonly required in your component's `Cargo.toml` for Ethereum interactions:

```toml
[dependencies]
# Core WAVS blockchain functionality
wit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait
wavs-wasi-chain = { workspace = true }  # HTTP utilities

# Alloy crates for Ethereum interaction
alloy-sol-types = { workspace = true }  # ABI handling & type generation
alloy-sol-macro = { workspace = true }  # sol! macro for interfaces
alloy-primitives = { workspace = true } # Core primitive types (Address, U256, etc.)
alloy-network = "0.11.1"                 # Network trait and Ethereum network type
alloy-provider = { version = "0.11.1", default-features = false, features = ["rpc-api"] } # RPC provider
alloy-rpc-types = "0.11.1"                # RPC type definitions (TransactionRequest, etc.)

# Other useful crates
anyhow = { workspace = true }          # Error handling
serde = { workspace = true }           # Serialization/deserialization
serde_json = { workspace = true }      # JSON handling
```

### Chain Configuration

Chain configurations are defined in the root `wavs.toml` file. This allows components to access RPC endpoints and chain IDs without hardcoding them.

```toml wavs.toml
[chains.eth.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"

[chains.eth.mainnet]
chain_id = "1"
ws_endpoint = "wss://mainnet.infura.io/ws/v3/YOUR_INFURA_ID"
http_endpoint = "https://mainnet.infura.io/v3/YOUR_INFURA_ID"
```

### Accessing Configuration and Provider

WAVS provides host bindings to get the chain config for a given chain name in the wavs.toml file:

```rust lib.rs
// Get the chain config for an Ethereum chain
let chain_config = host::get_eth_chain_config(&chain_name)?;

// Get the chain config for a Cosmos chain
let chain_config = host::get_cosmos_chain_config(&chain_name)?;
```

You can then use `wavs-wasi-chain` to create an RPC provider using the [`new_eth_provider` function](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/ethereum/fn.new_eth_provider.html):

```rust lib.rs
use crate::bindings::host::{get_eth_chain_config, get_cosmos_chain_config}; // Import host functions
use wavs_wasi_chain::ethereum::new_eth_provider;
use alloy_provider::{Provider, RootProvider};
use alloy_network::Ethereum;
use anyhow::Context; // For context() error handling

// Get the chain config for a specific chain defined in wavs.toml
let chain_config = get_eth_chain_config("eth.local") // Use the key from wavs.toml (e.g., "eth.local" or "eth.mainnet")
    .map_err(|e| format!("Failed to get chain config: {}", e))?;

// Create an Alloy provider instance using the HTTP endpoint
let provider: RootProvider<Ethereum> = new_eth_provider::<Ethereum>(
    chain_config.http_endpoint
        .context("http_endpoint is missing in chain config")? // Ensure endpoint exists
)?;
```

### Example: Querying NFT Balance

Here's an example demonstrating how to query the balance of an ERC721 NFT contract for a given owner address.

```rust lib.rs
use crate::bindings::host::get_eth_chain_config;
use alloy_network::{Ethereum, Network};
use alloy_primitives::{Address, Bytes, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::{TransactionInput, eth::TransactionRequest}; // Note: use eth::TransactionRequest
use alloy_sol_types::{sol, SolCall}; // Removed unused SolType, SolValue
use wavs_wasi_chain::ethereum::new_eth_provider;
use anyhow::Context;
use wstd::runtime::block_on; // Required to run async code

// Define the ERC721 interface subset needed
sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
    }
}

// Function to query NFT ownership (must be async)
pub async fn query_nft_ownership(owner_address: Address, nft_contract: Address) -> Result<bool, String> {
    // 1. Get chain configuration (using "eth.local" as an example)
    let chain_config = get_eth_chain_config("eth.local")
        .map_err(|e| format!("Failed to get eth.local chain config: {}", e))?;

    // 2. Create Ethereum provider
    let provider: RootProvider<Ethereum> = new_eth_provider::<Ethereum>(
        chain_config.http_endpoint
            .context("http_endpoint missing for eth.local")?
    ).map_err(|e| format!("Failed to create provider: {}", e))?; // Handle provider creation error

    // 3. Prepare the contract call using the generated interface
    let balance_call = IERC721::balanceOfCall { owner: owner_address };

    // 4. Construct the transaction request for a read-only call
    let tx = TransactionRequest {
        to: Some(TxKind::Call(nft_contract)), // Specify the contract to call
        input: TransactionInput {
            input: Some(balance_call.abi_encode().into()), // ABI-encoded call data
            data: None // `data` is deprecated, use `input`
        },
        // Other fields like nonce, gas, value are not needed for eth_call
        ..Default::default()
    };

    // 5. Execute the read-only call using the provider
    // Note: provider.call() returns the raw bytes result
    let result_bytes = provider.call(&tx)
        .await
        .map_err(|e| format!("Provider call failed: {}", e))?;

    // 6. Decode the result (balanceOf returns uint256)
    // Ensure the result is exactly 32 bytes for U256::from_be_slice
    if result_bytes.len() != 32 {
        return Err(format!("Unexpected result length: {}", result_bytes.len()));
    }
    let balance = U256::from_be_slice(&result_bytes);

    // 7. Determine ownership based on balance
    Ok(balance > U256::ZERO)
}

// Example of how to call the async function from the main sync component logic
fn main_logic(owner: Address, contract: Address) -> Result<bool, String> {
    let is_owner = block_on(async move {
        query_nft_ownership(owner, contract).await
    })?; // Use block_on to run the async function
    Ok(is_owner)
}
```

This example covers:
1.  **Defining the Interface**: Using `sol!` to create Rust bindings for the `balanceOf` function.
2.  **Provider Setup**: Getting configuration and creating an `alloy` provider.
3.  **Call Preparation**: Encoding the function call data using generated types.
4.  **Transaction Request**: Building the request for an `eth_call`.
5.  **Execution**: Using `provider.call()` to interact with the node.
6.  **Decoding**: Parsing the returned bytes into the expected `U256` type.
7.  **Async Handling**: Using `async fn` and `block_on` for asynchronous network operations within the synchronous component environment.

Visit the [wavs-wasi-chain documentation](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/index.html) and the [Alloy documentation](https://docs.rs/alloy/latest/alloy/) for more detailed information.
