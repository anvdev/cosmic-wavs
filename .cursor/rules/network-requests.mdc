---
description: How to make HTTP requests from WAVS components using wavs-wasi-utils
globs: **/*.rs
alwaysApply: true
---
# Network Requests in WAVS Components

Use the [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/index.html) crate to make HTTP requests from WAVS components. Since WASI runs synchronously, use `block_on` from the `wstd` crate to run async HTTP calls.

### Dependencies

Add these to `Cargo.toml`:

```toml
[dependencies]
wavs-wasi-utils = "0.4.0-beta.4"   # HTTP utilities
wstd = "0.5.3"                     # Runtime utilities (includes block_on)
serde = { version = "1.0.219", features = ["derive"] }  # Serialization
serde_json = "1.0.140"             # JSON handling
```

### HTTP Request Functions

- `http_request_get(url)` — creates a GET request
- `http_request_post_json(url, data)` — creates a POST request with JSON body
- `http_request_post_form(url, data)` — creates a POST request with form data

### Response Fetching Functions

- `fetch_json(request)` — fetches and parses JSON response
- `fetch_string(request)` — fetches response as string
- `fetch_bytes(request)` — fetches raw response bytes

### Example: GET Request with Custom Headers

```rust
use wstd::runtime::block_on;
use wstd::http::HeaderValue;
use wavs_wasi_utils::http::{fetch_json, http_request_get};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct ApiResponse {
    // ... your response fields
}

async fn make_request() -> Result<ApiResponse, String> {
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    let json: ApiResponse = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(json)
}

fn process_data() -> Result<ApiResponse, String> {
    block_on(async move { make_request().await })?
}
```

### Example: POST Request with JSON Data

```rust
use wstd::runtime::block_on;
use wavs_wasi_utils::http::{fetch_json, http_request_post_json};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct PostData {
    key1: String,
    key2: i32,
}

#[derive(Debug, Serialize, Deserialize)]
struct PostResponse {
    // ... response fields
}

async fn make_post_request() -> Result<PostResponse, String> {
    let url = "https://api.example.com/endpoint";
    let post_data = PostData {
        key1: "value1".to_string(),
        key2: 42,
    };
    let response: PostResponse = fetch_json(
        http_request_post_json(&url, &post_data)?
    ).await.map_err(|e| e.to_string())?;
    Ok(response)
}

fn process_data() -> Result<PostResponse, String> {
    block_on(async move { make_post_request().await })?
}
```

### Guidelines & Best Practices

1. Use `block_on` to run async HTTP requests in synchronous WASI components.
2. Use serde derives to serialize/deserialize JSON data automatically.
3. Set appropriate headers (e.g., `Accept`, `Content-Type`, `User-Agent`) for API requests.
4. Use `http_request_post_json` for JSON POST requests as it sets headers automatically.
5. Handle errors by converting them to strings for easier debugging.

For more information:
- [wavs-wasi-utils crate documentation](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/)
- [HTTP module docs](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/http/index.html)
- [Variables page](./variables)