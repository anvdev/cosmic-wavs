---
title: 6. Run your service
description: Deploying and running WAVS services
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

{/* todo: update once the template is updated */}
## Local: Start Anvil, WAVS, and deploy Eigenlayer

1. Create a `.env` file for your project by copying over the example with the following command:

```bash
cp .env.example .env
```

2. Use the following command to start an Anvil test chain, IPFS, Registry, and some optional telemetry. This only runs with `LOCAL` being set in the `.env` (default).

```bash docci-background docci-delay-after=5
make start-all-local
```

<Callout title="Keep WAVS running" type="info">

The command must remain running in your terminal. Open another terminal to run other commands.

You can stop the services with `ctrl+c`. Some MacOS terminals require pressing this twice.

</Callout>


With the chain and WAVS running, you can deploy and run your service.

## Create Deployer

An account is required to upload the contracts and be the original admin of them. This script creates a new wallet then sets a balance if using a local deployment, or waits until it has testnet funds before returning.

You can skip this step by setting `FUNDED_KEY=` in `.env` to a private key of your choice that has network funds.

```bash docci-delay-after=2
sh ./script/create-deployer.sh
```

## Deploy Eigenlayer Middleware

Local deployments use the real testnet contracts via a forked anvil instance. This middleware will setup all the required contracts and configurations for the base of your AVS.

```bash docci-delay-after=2
docker run --rm --network host --env-file .env -v ./.nodes:/root/.nodes ghcr.io/lay3rlabs/wavs-middleware:0.4.0-beta.5
```

## Deploy solidity contracts

```bash docci-delay-per-cmd=2
export RPC_URL=`sh ./script/get-rpc.sh`
export DEPLOYER_PK=$(cat .nodes/deployer)
export SERVICE_MANAGER_ADDRESS=$(jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json)

# Upload
forge create SimpleSubmit --json --broadcast -r ${RPC_URL} --private-key "${DEPLOYER_PK}" --constructor-args "${SERVICE_MANAGER_ADDRESS}" > .docker/submit.json
export SERVICE_SUBMISSION_ADDR=`jq -r '.deployedTo' .docker/submit.json`

forge create SimpleTrigger --json --broadcast -r ${RPC_URL} --private-key "${DEPLOYER_PK}" > .docker/trigger.json
export SERVICE_TRIGGER_ADDR=`jq -r '.deployedTo' .docker/trigger.json`
```

## Deploy Service

Deploy the compiled component with the contract information from the previous steps.

```bash docci-delay-per-cmd=3
# ** Testnet Setup: https://wa.dev/account/credentials
#
# If you get errors: warg reset --registry http://127.0.0.1:8090

export COMPONENT_FILENAME=evm_price_oracle.wasm
export REGISTRY=`sh ./script/get-registry.sh`
export PKG_NAME="evmrustoracle"
export PKG_VERSION="0.1.0"
export PKG_NAMESPACE=`sh ./script/get-wasi-namespace.sh`

# Upload the component to the registry
# local or wa.dev depending on DEPLOY_ENV in .env
sh script/upload-to-wasi-registry.sh

# Build your service JSON
export AGGREGATOR_URL=http://127.0.0.1:8001

# Testnet: set values (default: local if not set)
# export TRIGGER_CHAIN=holesky
# export SUBMIT_CHAIN=holesky

# Package not found with wa.dev? -- make sure it is public
REGISTRY=${REGISTRY} sh ./script/build_service.sh
```


## Upload to IPFS

```bash docci-delay-per-cmd=2
# Upload service.json to IPFS
export SERVICE_FILE=.docker/service.json

# local: 127.0.0.1:5001
# testnet: https://app.pinata.cloud/. set PINATA_API_KEY to JWT token in .env
export ipfs_cid=`SERVICE_FILE=${SERVICE_FILE} make upload-to-ipfs`

# LOCAL: http://127.0.0.1:8080
# TESTNET: https://gateway.pinata.cloud/
export IPFS_GATEWAY=$(sh script/get-ipfs-gateway.sh)

export SERVICE_URI="${IPFS_GATEWAY}/ipfs/${ipfs_cid}"
curl ${SERVICE_URI}

cast send ${SERVICE_MANAGER_ADDRESS} 'setServiceURI(string)' "${SERVICE_URI}" -r ${RPC_URL} --private-key ${DEPLOYER_PK}
```

## Aggregator

```bash docci-delay-per-cmd=2
# create wavs-aggregator-1
sh ./script/create-aggregator.sh 1

# start the aggregator
sh ./infra/aggregator-1/start.sh

# Register the service with the aggregator
wget -q --header="Content-Type: application/json" --post-data='{"service": '"$(jq -c . ${SERVICE_FILE})"'}' ${AGGREGATOR_URL}/register-service -O -
```

## WAVS

```bash
# create wavs-1
sh ./script/create-operator.sh 1

# start WAVS
sh ./infra/wavs-1/start.sh

# Deploy the service JSON to WAVS so it now watches and submits.
# 'opt in' for WAVS to watch (this is before we register to Eigenlayer)
WAVS_ENDPOINT=http://127.0.0.1:8000 SERVICE_URL=${SERVICE_URI} make deploy-service
```

## Register service specific operator

Each service gets its own key path (hd_path). The first service starts at 1 and increments from there. Get the service ID

```bash
export SERVICE_ID=`curl -s http://localhost:8000/app | jq -r '.services[0].id'`
export HD_INDEX=`curl -s http://localhost:8000/service-key/${SERVICE_ID} | jq -rc .secp256k1.hd_index | tr -d '[]'`

source infra/wavs-1/.env
AVS_PRIVATE_KEY=`cast wallet private-key --mnemonic-path "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index ${HD_INDEX}`
OPERATOR_ADDRESS=`cast wallet address ${AVS_PRIVATE_KEY}`

# Register the operator with the WAVS service manager
export WAVS_SERVICE_MANAGER_ADDRESS=`jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json`
DELEGATION=0.001ether AVS_PRIVATE_KEY=${AVS_PRIVATE_KEY} make V=1 operator-register

# Verify registration
WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS} make operator-list
```


## Trigger the service

Next, use your deployed trigger contract to trigger the oracle to be run. In the following command, you'll specify the `COIN_MARKET_CAP_ID` as `1`, which corresponds to the ID of Bitcoin.

Running this command will execute [`/script/Trigger.s.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/script/Trigger.s.sol) and pass the ID to the trigger contract, starting the following chain of events:

1. The trigger contract will emit an event with the specified ID as its data.
2. Operators listening for the event will receive the data and run it in the oracle component off-chain.
3. The oracle component will use the ID to query the price of Bitcoin from the CoinMarketCap API.
4. The returned data will be signed by operators and passed to the submission contract, which will verify the operator's signature and submit the price of Bitcoin on-chain ðŸŽ‰


```bash docci-delay-per-cmd=2
export COIN_MARKET_CAP_ID=1
export SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`
forge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig 'run(string,string)' --rpc-url http://localhost:8545 --broadcast
```

## Show the result

Run the following to view the result of your service in your terminal:

```bash docci-delay-per-cmd=2 docci-output-contains="BTC"
# Get the latest TriggerId and show the result via `script/ShowResult.s.sol`
TRIGGER_ID=1 RPC_URL=${RPC_URL} make show-result
```

Congratulations, you've just made a simple Bitcoin price oracle service using WAVS!
