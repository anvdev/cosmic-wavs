# Creating WAVS components

You started a new job at Layer Labs. Your task is to create new components that run using WAVS, a WASI runtime for AVSs. Read this guide carefully, as it will orient you on how to build services. The repo you are in is a foundry template with an existing example in components/eth-price-oracle/. This repo uses a makefile to streamline commands.

## Commands

The only commands needed to test if a component is made correctly are:

1. `make wasi-build`: this command builds every component in the /component directory, generates bindings automatically (you do not ever need to write or edit a bindings.rs file!), automatically compiles components to wasm, and places them automatically in the /compiled folder. component `/eth-price-oracle` becomes `eth_price_oracle.wasm`.

2. The `make wasi-exec` command. IMPORTANT! As an LLM, you cannot execute the `wasi-exec` command directly. Provide the command to the user and ask them to run manually in their terminal:

```bash
# Choose the appropriate format for your component's input data:
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # For strings (with null byte padding up to 32 bytes)
# Or use other formats based on your needs:
# export TRIGGER_DATA_INPUT=`cast abi-encode "f(uint256)" 123456` # For numeric inputs
# export TRIGGER_DATA_INPUT=`cast abi-encode "f((uint256,string))" 123 "example"` # For struct inputs
# export TRIGGER_DATA_INPUT="0x1234abcd" # For raw hex data

export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[],\"kv\":[],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # The service config

make wasi-exec
```

## Environment variables

You can set public and private variables in components.
1. public
   - set in `SERVICE_CONFIG` `kv` array
2. private
   - set in `SERVICE_CONFIG` `host_envs` array
   - MUST be prefixed with `WAVS_ENV_`
   - This variable is set in the .env file in the root of this repo. Use the following steps:
     1. see if `.env` exists: `ls -la .env`
     - If there is no .env file, use `cp .env.example .env`.
     1. Before adding, check if the variable already exists to avoid duplicates
     1. Add your private variable WITHOUT quotes:
```bash
sed -i '' '1i\
WAVS_ENV_MY_API_KEY=your_secret_key_here
' .env
```

Use in component:

```rust
let endpoint = std::env::var("api_endpoint")?;
let api_key = std::env::var("WAVS_ENV_MY_API_KEY")?;
```

IMPORTANT: NEVER hardcode API keys directly in components. Always store API keys and other sensitive data as environment variables using the method above. Do not use quotes in the .env file values as they may cause URL formatting errors.

Set in command:

```bash
export TRIGGER_DATA_INPUT=`cast format-bytes32-string 1` # your input data for testing the component. Make sure this is formatted correctly for your component.
export COMPONENT_FILENAME=eth_price_oracle.wasm # the filename of your compiled component.
export SERVICE_CONFIG="'{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[\"WAVS_ENV_MY_API_KEY\"],\"kv\":[[\"api_endpoint\",\"https://api.example.com\"]],\"workflow_id\":\"default\",\"component_id\":\"default\"}'" # public variable set in kv.

# REMEMBER: As an LLM, you cannot execute this command directly.
# Provide these instructions to the user and ask them to run manually in their terminal:
make wasi-exec
```

## Foundry Template structure

The foundry template is made up of the following main files:

```bash
wavs-foundry-template/
├── README.md
├── makefile               # Commands, variables, and configs
├── components/            # WASI components
│   └── eth-price-oracle/
│       ├── Cargo.toml     # Component dependencies
│       ├── lib.rs         # Main Component logic
│       └── bindings.rs    # Bindings generated by `make build`
├── compiled/              # WASM files compiled by `make build`
├── src/
│   ├── contracts/        # Trigger and submission contracts
│   └── interfaces/       # Solidity interfaces
├── script/               # Scripts used in makefile commands
├── cli.toml              # CLI configuration
├── wavs.toml             # WAVS service configuration
├── docs/                 # Documentation
└── .env                  # Private environment variables
```

- The `README` file contains the tutorial commands.
- The `makefile` contains commands for building and deploying the service. It also contains variables and configs for the service.
- The components directory contains the component logic for your service. Running `make wasi-build` will automatically generate bindings and compile components into the `compiled` directory.
- The src directory contains the Solidity contract and interfaces.
- The script directory contains the scripts used in the makefile commands to deploy, trigger, and test the service.
- The `.env` file contains private environment variables and keys. Use `cp .env.example .env` to copy the example `.env` file.

## WAVS services

The basic service is made up of a trigger, a component, and submission logic (optional).

[Trigger](#triggers): any onchain event emitted from a contract.

[Component](#components): the main logic of a WAVS service. Components are responsible for processing the trigger data and executing the business logic.

[Submission](#submission): handles the logic for submitting a component's output to the blockchain.

## Triggers

A trigger prompts a WAVS service to run. Operators listen for the trigger event specified by the service and execute the corresponding component off-chain. Triggers can be any onchain event emitted from any contract.

### Trigger lifecycle

1. When a service is deployed, it is configured with a trigger address and event, a wasi component, and a submission contract (optional).

2. Registered operators listen to chain logs. Each operator maintains lookup maps and verifies events against registered triggers.

3. When a trigger event is emitted, operators pick up the event and verify the event matches the registered trigger.

4. If a match is found, WAVS creates a `TriggerAction` that wraps the trigger event data:

```rust
TriggerAction {
    // Service and workflow identification
    config: TriggerConfig {
       service_id: ServiceID,      // Generated during deployment
        workflow_id: WorkflowID,    // Default or specified
        trigger: Trigger::EthContractEvent {
           address: Address,       // Contract address
            chain_name: ChainName,  // Chain identifier
            event_hash: ByteArray<32> // Event signature
        }
    },
   // The actual event data
    data: TriggerData::EthContractEvent {
        contract_address: Address,  // Emitting contract
        chain_name: ChainName,      // Source chain
        log: LogData {             // Raw event data
            topics: Vec<Vec<u8>>,  // Event signature + indexed params
            data: Vec<u8>         // ABI-encoded event data
        },
        block_height: u64         // Block number
    }
}
```

5. The TriggerAction is converted to a WASI-compatible format and passed to the component where it is decoded and processed.

### Developing triggers

WAVS doesn't interpret the contents of event triggers. Instead, it passes the raw log data to components, which can decode and process the data according to their specific needs.

## Components

WASI components contain the main logic of a WAVS service. They are responsible for processing the trigger data and executing the business logic of a service.

A basic component has three main parts:

- Decoding incoming trigger data.
- Processing the data (this is the custom logic of your component).
- Encoding and returning the result for submission (if applicable).

When creating a new component, it's strongly recommended to:
1. Copy the Cargo.toml from the eth-price-oracle example and modify only the name
2. Use workspace dependencies with `{ workspace = true }` instead of specific versions
3. Create lib.rs file similar to the example component

After being passed the `TriggerAction`, the component decodes it using the `decode_event_log_data!` macro from the [`wavs-wasi-chain`](https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions) crate.

Components must implement the `Guest` trait, which is the main interface between your component and the WAVS runtime. The `run` function is the entry point for processing triggers: it should receive the trigger data, decode it, process it according to your component's logic, and return the results. If you need to submit results to the blockchain, results need to be encoded using `abi_encode()`.

The `sol!` macro from `alloy_sol_types` is used to define Solidity types in Rust. It generates Rust structs and implementations that match your Solidity types, including ABI encoding/decoding methods.

IMPORTANT: Always import the required traits if using these methods:
```rust
use alloy_sol_types::{sol, SolCall, SolValue}; // SolCall needed for abi_encode() on call structs
```

Bindings are automatically generated for any files in the `/components` and `/src` directories when the `make build` command is run.

## Common Type and Data Handling Issues

When building components, you'll need to handle several common issues:

### 1. Rust-Solidity Type Conversions

Solidity and Rust have different type systems. For numeric types:

```rust
// String parsing method - works reliably for all numeric types including Uint<256,4>
let temperature: u128 = 29300;
let temperature_uint256 = temperature.to_string().parse().unwrap();

// AVOID .into() for numeric conversions to Solidity types - it often fails
// let temp_uint = temperature.into(); // DON'T DO THIS - will often fail
```

### 2. Binary Data Handling

When working with Solidity structs that contain binary data:

```rust
// IMPORTANT: Always convert Vec<u8> to Bytes explicitly for Solidity data fields
// Use the correct import path: use wavs_wasi_chain::ethereum::alloy_primitives::Bytes;
let data_with_id = solidity::DataWithId {
    triggerId: trigger_id,
    data: Bytes::from(result.abi_encode()), // Convert Vec<u8> to Bytes
};
```

### 3. String Input Processing

When using string inputs via format-bytes32-string:

```rust
// 1. ALWAYS clone before using String::from_utf8 to avoid ownership errors
let input_string = String::from_utf8(trigger_data.clone())
    .map_err(|e| format!("Failed to convert input to string: {}", e))?;

// 2. ALWAYS trim null bytes added by format-bytes32-string before using in URLs or API calls
// This is CRITICAL for API URLs or your requests will DEFINITELY fail
let clean_input = input_string.trim_end_matches('\0');

// Now safe to use in URLs or other contexts
let url = format!("https://api.example.com/endpoint?param={}", clean_input);

// ALWAYS print the URL before sending requests to debug formatting issues
println!("Debug - Request URL: {}", url);
```

CRITICAL: String inputs via format-bytes32-string MUST be trimmed of null bytes before using in URLs or API calls. This is the most common cause of "invalid URI character" errors.

### 4. Event Log Decoding

When using the decode_event_log_data! macro:

```rust
// Always clone the log before decoding to avoid ownership errors
let log_clone = log.clone();
let event: MyEvent = decode_event_log_data!(log_clone)?;
```

### 5. Data Structure Ownership

When working with data structures in Rust, especially with API responses:

```rust
// CRITICAL: Always derive Clone for ALL data structures used in API responses
// Missing Clone derivation is a common source of build errors
#[derive(Serialize, Deserialize, Debug, Clone)]
struct ApiResponse {
    name: String,
    description: String,
    // other fields...
}

// WRONG - Will cause "borrow of partially moved value" errors:
let weather_struct = WeatherData {
    city: api_response.name, // This moves the string from api_response
    // other fields...
};
let json_data = serde_json::to_vec(&api_response)?; // ERROR: api_response partially moved

// CORRECT - Process in the right order:
let json_data = serde_json::to_vec(&api_response)?; // Use the complete struct first
let weather_struct = WeatherData {
    city: api_response.name, // Then move fields
    // other fields...
};

// ALSO CORRECT - Use clone to avoid ownership issues entirely:
let weather_struct = WeatherData {
    city: api_response.name.clone(), // Clone prevents moving from api_response
    // other fields...
};
let json_data = serde_json::to_vec(&api_response)?; // Works fine now
```

## Input and Output Handling

Components can receive trigger data in two ways:

1. Via an onchain event (after deployment)
2. Via the `wasi-exec` command (for testing)

### Input Data Formatting for Testing

When providing testing instructions for `make wasi-exec`, choose the appropriate data format based on your component's input processing:

1. **String inputs**:
   ```bash
   # For short strings (< 32 bytes):
   export TRIGGER_DATA_INPUT=`cast format-bytes32-string "90210"`
   # IMPORTANT: This adds null byte padding that MUST be trimmed in component code:
   # clean_input = input_string.trim_end_matches('\0')

   # For longer strings or when exact format matters:
   export TRIGGER_DATA_INPUT=`cast abi-encode "f(string)" "your long string here"`
   ```

2. **Ethereum addresses**:
   ```bash
   # ALWAYS use abi-encode for addresses to ensure proper encoding:
   export TRIGGER_DATA_INPUT=`cast abi-encode "f(address)" 0xf3d583d521cC7A9BE84a5E4e300aaBE9C0757229`
   ```

3. **Numeric inputs**:
   ```bash
   export TRIGGER_DATA_INPUT=`cast abi-encode "f(uint256)" 123456` # For uint256 values
   ```

4. **Custom struct inputs**:
   ```bash
   export TRIGGER_DATA_INPUT=`cast abi-encode "f((uint256,string))" 123 "example"` # For structs
   ```

5. **Raw hex data**:
   ```bash
   export TRIGGER_DATA_INPUT="0x1234abcd" # For simple binary formats
   ```

Your component must handle these input formats appropriately. Build flexible input handlers that can detect and process different encoding formats based on data length and structure.

## Network Requests

Components can make HTTP requests using the `wavs-wasi-chain` crate and `block_on` for async handling:

```rust
use wstd::runtime::block_on;  // Required for running async code
use wavs_wasi_chain::http::{fetch_json, http_request_get}; // Correct import path
use wstd::http::HeaderValue; // For setting headers

// IMPORTANT: All API response structs MUST derive Clone
#[derive(Serialize, Deserialize, Debug, Clone)] // Clone prevents ownership errors
struct ResponseType {
    field1: String,
    field2: u64,
}

// The request function must be async
async fn make_request() -> Result<ResponseType, String> {
    // IMPORTANT: When formatting URLs with parameters, be careful with special characters
    // For debugging URL issues, always print the URL before making the request
    let url = "https://api.example.com/endpoint";
    println!("Debug - Request URL: {}", url);
    // Create request with proper headers
    let mut req = http_request_get(&url)
        .map_err(|e| format!("Failed to create request: {}", e))?;
    
    // Add appropriate headers 
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    
    // Parse JSON response
    let response: ResponseType = fetch_json(req).await
        .map_err(|e| format!("Failed to fetch data: {}", e))?;
    Ok(response)
}

// Use block_on in the main component logic
fn process_data() -> Result<ResponseType, String> {
    block_on(async { make_request().await })
}
```

## Best Practices

To build reliable components:

### Creating New Components

When creating a new component, follow these steps to avoid common errors:

1. **Start by copying the example component**:
   - Copy the `eth-price-oracle` component's Cargo.toml and modify only the name
   - Create a lib.rs module similar to the `eth-price-oracle`
   - Use the existing component structure as a template

2. **Configure dependencies correctly**:
   - Use workspace dependencies with `{ workspace = true }` syntax
   - NEVER specify direct version numbers in component Cargo.toml
   - For new functionality, add dependencies to workspace Cargo.toml first, then reference with `{ workspace = true }`
   - Consider standard library alternatives before adding new dependencies
   - Import HTTP functions from the correct submodule: `wavs_wasi_chain::http::{fetch_json, http_request_get}`

3. **Handle data ownership properly**:
   - ALWAYS clone data before consuming: `data.clone()` before passing to String::from_utf8()
   - ALWAYS clone logs for decoding: `let log_clone = log.clone()`
   - ALWAYS clone collection elements: `array[0].field.clone()` to avoid "move out of index" errors
   - ALWAYS trim string input nulls: `trim_end_matches('\0')` on all format-bytes32-string inputs
   - ALWAYS use string parsing for numbers: `value.to_string().parse()` for Solidity numeric types (avoid .into())
   - ALWAYS use correct Bytes import: `use wavs_wasi_chain::ethereum::alloy_primitives::Bytes`
   - Be careful with Solidity types defined with sol! macro - they can't be directly imported between files with syntax like `trigger::sol::Type` - either define them where needed or create a module to export them

4. **Structure your component for both testing and production**:
   - Implement proper destination-based output handling (CLI vs Ethereum)
   - Include detailed error messages with context in all error cases

### Development Process

1. Build and test incrementally
2. Validate each step with println!() statements during development
3. Always run `make wasi-build` after making changes to regenerate bindings
4. Test with expected formatting (string inputs, numeric inputs, etc.)
5. Remove debug statements before production

### Pre-Deployment Checklist

- Verify all type conversions are handled correctly
- Confirm proper error handling throughout
- Test with actual input formats to verify handling
- Ensure all sensitive data is in environment variables
- Validate output format matches expected contract format
- CRITICAL: Verify all data structures used with API responses implement `Clone` - missing this will cause build errors
- Confirm string inputs from format-bytes32-string are trimmed of null bytes

## Example trigger logic

Here's an example of trigger logic that handles data extraction properly:

```rust
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent};
use alloy_sol_types::{sol, SolCall, SolValue}; // SolCall trait is required for abi_encode methods
use anyhow::Result;
use wavs_wasi_chain::{decode_event_log_data, ethereum::alloy_primitives::Bytes};

pub enum Destination {
    Ethereum,  // Return data for on-chain submission
    CliOutput, // Return data for CLI testing
}

// Define your event and struct types
sol! {
    event MyEvent(uint64 indexed requestId, string dataString);
    
    struct DataWithId {
        uint64 triggerId;
        bytes data;
    }
}

pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {
            // ALWAYS clone before using decode_event_log_data!
            let log_clone = log.clone();
            let event: MyEvent = decode_event_log_data!(log_clone)?;
            Ok((event.requestId, event.dataString.as_bytes().to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> Vec<u8> {
    // Convert Vec<u8> to Bytes for Solidity compatibility
    DataWithId {
        triggerId: trigger_id,
        data: Bytes::from(output.as_ref().to_vec()),
    }
    .abi_encode()
}
```

## Troubleshooting Common Errors

| Error Type | Symptom | Solution |
|------------|---------|----------|
| Dependency Version | "failed to select a version for..." | Copy Cargo.toml from eth-price-oracle and only change the name |
| Missing Dependency | "unresolved module or crate" | Add the dependency to workspace Cargo.toml first, then reference with `{ workspace = true }` |
| Import Path | "unresolved imports http_request_get" | Use: `use wavs_wasi_chain::http::{fetch_json, http_request_get}` |
| Type Conversion | "expected Uint<256, 4>, found u128" | Use string parsing: `value.to_string().parse().unwrap()` |
| Binary Type Mismatch | "expected Bytes, found Vec<u8>" | Use: `Bytes::from(data)` with correct import |
| Event Decoding | "cannot move out of log.data" | ALWAYS clone: `let log_clone = log.clone()` |
| String Handling | URL formatting errors | ALWAYS trim nulls: `string.trim_end_matches('\0')`, debug with `println!("URL: {}", url)` |
| Input Format | "bytes32 strings must not exceed 32 bytes" | For addresses, use `cast abi-encode "f(address)" 0xAddress`; for long strings use `cast abi-encode "f(string)" "text"` |
| HTTP Requests | "invalid uri character" | Check for special characters in URLs, use debug prints to identify issues |
| Ownership Issues | "use of moved value" | Clone data before use: `data.clone()` |
| Collection Access | "cannot move out of index" | Clone when accessing: `array[0].field.clone()` |
| TriggerAction Access | "no field data_input on type TriggerAction" | Use trigger.rs module like the example instead of direct access |
| Environment Variables | API key access issues | Include in SERVICE_CONFIG "host_envs" array AND in .env file with WAVS_ENV_ prefix |
| Option Handling | "no method named `map_err` found for enum `Option`" | Use `.ok_or_else(|| "error message".to_string())?` for Option types, not `.map_err()` |
| Serialization Error | "trait `Serialize` not implemented for struct from sol! macro" | Create a separate struct with `#[derive(Serialize)]` for JSON output |
| Partially Moved Value | "borrow of partially moved value" | Process data in correct order: serialize/use struct *before* moving its fields |
| Solidity Type Import | "could not find `sol` in module" | Define Solidity types where needed - can't import using `trigger::sol::` syntax |

For more details on specific topics, refer to `/docs/custom-components.mdx` or https://docs.rs/wavs-wasi-chain/latest/wavs_wasi_chain/all.html#functions.

## Blockchain Interactions

For components that interact directly with blockchains you MUST add the following dependencies:

In workspace Cargo.toml, add:
```toml
alloy-primitives = "0.8.25"  # Core types (Address, U256)
alloy-provider = { version = "0.11.1", default-features = false, features = ["rpc-api"] }
alloy-rpc-types = "0.11.1"  # RPC definitions
alloy-network = "0.11.1"    # Network trait
```

Then in component Cargo.toml, use:
```toml
alloy-primitives = { workspace = true }
alloy-provider = { workspace = true }
alloy-rpc-types = { workspace = true }
alloy-network = { workspace = true }
```

### Example

Use host bindings to get chain config from wavs.toml:

```rust
use std::io::Read;

use crate::bindings::host::get_eth_chain_config;
use alloy_network::{AnyNetwork, Ethereum, Network};
use alloy_primitives::{Address, Bytes, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use alloy_sol_types::{sol, SolCall, SolType, SolValue};
use wavs_wasi_chain::ethereum::new_eth_provider;

sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
    }
}

pub async fn query_nft_ownership(address: Address, nft_contract: Address) -> Result<bool, String> {
    let chain_config = get_eth_chain_config("mainnet")
    .ok_or_else(|| "Failed to get Ethereum chain config".to_string())?;
    let provider: RootProvider<Ethereum> =
        new_eth_provider::<Ethereum>(chain_config.http_endpoint
            .clone()
            .ok_or("No HTTP endpoint in chain config")?);

    let balance_call = IERC721::balanceOfCall { owner: address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(nft_contract)),
        input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
        ..Default::default()
    };

    let result = provider.call(&tx).await.map_err(|e| e.to_string())?;
    let balance: U256 = U256::from_be_slice(&result);
    Ok(balance > U256::ZERO)
}
```

CRITICAL: All blockchain interactions must use async functions with `block_on`. Never hardcode RPC endpoints - always use chain configuration from wavs.toml.
