# Cryptography 

 
## Overview of BLS12-381  
BLS12-381 is a pairing-based cryptographic scheme used for digital signatures, particularly known for its ability to aggregate multiple signatures into a single compact signature.
 
In BLS signatures:
- **Public keys** are typically 48bytes in `G1`.
- **Signatures** are typically 96bytes in `G2`.
- **Pairing** operations map pairs of `G1` and `G2` points to GT to verify signatures.


### DST: Domain Separation Tags
The domain separation tags (`DST`) ensure that hashed data (e.g., messages or proofs of possession) are distinct for different purposes, preventing attacks like reusing a signature in a different context.

#### Commonware Cryptography
This AVS makes use of the commonware-cryptography library for operators specific to bls key use. The function by default provides the DST to the message being signed, as well as an additional namespace prefix to further assign verification use. 
 
Make sure to make use of this DST for any external library validating bls12-381 signatures.
```rs
/// comswasm-std veficiation example

/// Domain separation tag for hashing a message to G2.
pub const G2_MESSAGE: DST = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";
 
// perform native authenticcation workflow in cosmwasm-std
let hashed_message = deps.api.bls12_381_hash_to_g2(
    HashFunction::Sha256,
    &to_json_binary(&auth_req.tx_data.msgs)?,  
    G2_MESSAGE,
)?;

  // Verify the signature using pairing equality: e(g1, signature) == e(pubkey, H(message))
  if !deps.api.bls12_381_pairing_equality(
      &BLS12_381_G1_GENERATOR,
      &aggregated_signature,
      &aggregated_pubkey,
      &hashed_message,
  )? {
      return Err(ContractError::VerificationError(
          cosmwasm_std::VerificationError::GenericErr,
      ));
  }
```

### Explanation of Each Type and Constant

#### 1. **G1 (blst_p1)**
- **Definition**: `#[derive(Clone, Copy, Eq, PartialEq)] #[repr(transparent)] pub struct G1(blst_p1);`
  - Represents a point on the BLS12-381 G1 curve, wrapping the `blst_p1` type from the `blst` library (a low-level BLS12-381 implementation).
  - `#[repr(transparent)]` ensures the memory layout is identical to `blst_p1`, facilitating safe FFI (Foreign Function Interface) with C code.
  - G1 points are smaller (compressed to 48 bytes, as per `G1_ELEMENT_BYTE_LENGTH`) due to the curve’s properties.

- **When Used**:
  - **Public Keys**: In BLS12-381, public keys are typically G1 points. A private key (a scalar in \( \mathbb{F}_r \)) is multiplied by the G1 generator to produce a public key: \( PK = sk \cdot G_1 \), where \( G_1 \) is the G1 generator.
  - **Proof of Possession (PoP)**: G1 points are used when verifying a PoP, where a public key (G1) is hashed to G2 for signing.
  - **Verification**: In signature verification, a G1 point (public key) is paired with a G2 point (hashed message or signature) to produce a GT element.

- **Role in BLS Signatures**:
  - When verifying a signature, the public key (G1) is used in the pairing equation: \( e(PK, H(m)) = e(G_1, \sigma) \), where \( PK \) is the public key, \( H(m) \) is the hashed message (G2), and \( \sigma \) is the signature (G2).

#### 2. **G1_ELEMENT_BYTE_LENGTH: usize = 48**
- **Definition**: Specifies that a compressed G1 point is encoded as 48 bytes.
- **Why**: G1 points are compressed to save space (using only the x-coordinate and a bit to indicate the y-coordinate’s sign). This is standard for BLS12-381 G1 points.
- **When Used**: During serialization/deserialization of G1 points (e.g., public keys or aggregated public keys) for storage, transmission, or verification.

#### 3. **G1_MESSAGE: DST = b"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_POP_"**
- **Definition**: A domain separation tag (DST) for hashing messages to G1 points, using the `POP` (Proof of Possession) scheme.
- **Purpose**: Ensures that messages hashed to G1 are distinct from other hashed data (e.g., PoP or G2 messages), preventing cross-protocol attacks.
- **Details**:
  - Uses the `XMD:SHA-256_SSWU_RO_POP_` ciphersuite, which specifies:
    - **XMD**: Expanded Message Digest (hashing with SHA-256).
    - **SSWU**: Simplified Shallue-Woestijne-Ulas (a method to map hashes to curve points).
    - **RO**: Random Oracle model.
    - **POP_**: Indicates the Proof of Possession scheme, which mitigates rogue key attacks in aggregated signatures.
- **When Used**:
  - When a message needs to be hashed to a G1 point, typically for alternative BLS signature schemes where signatures are in G1 and public keys are in G2 (less common but supported).
  - In the provided library, messages are hashed to G2 (`G2_MESSAGE`), but `G1_MESSAGE` is defined for cases where the signature scheme swaps groups (e.g., public keys in G2, signatures in G1).
  - Example: If signing a message \( m \), it’s hashed to G1: \( H(m) = \text{hash_to_g1}(m, \text{G1_MESSAGE}) \), and the signature is \( \sigma = sk \cdot H(m) \).

#### 4. **G1_PROOF_OF_POSSESSION: DST = b"BLS_POP_BLS12381G1_XMD:SHA-256_SSWU_RO_POP_"**
- **Definition**: A DST for hashing a proof of possession (typically a compressed G2 point) to a G1 point.
- **Purpose**: Used in the Proof of Possession (PoP) scheme to prove that a signer controls the private key corresponding to a public key, preventing rogue key attacks in aggregated signatures.
- **When Used**:
  - **Proof of Possession**: A PoP is a signature over the public key itself. For a public key \( PK \) (G1), the signer creates a PoP by:
    1. Hashing the public key to G2 using `G2_PROOF_OF_POSSESSION` (explained below).
    2. Signing it with the private key to produce a PoP (G2 point).
    3. In some cases, the PoP process may involve hashing to G1 (e.g., if the PoP signature is in G1), which uses `G1_PROOF_OF_POSSESSION`.
  - **Context**: In a Byzantine environment (as noted in the code), PoP is critical for aggregated signatures to ensure each public key is legitimate. For example, when aggregating signatures, verifiers require a PoP for each public key to prevent an attacker from submitting a malicious public key that cancels out others.
  - Example: To create a PoP, the public key \( PK \) (G1) is hashed to G2, signed, and the PoP may be verified by hashing the PoP to G1 using `G1_PROOF_OF_POSSESSION`.

#### 5. **G2 (blst_p2)**
- **Definition**: `#[derive(Clone, Copy, Eq, PartialEq)] #[repr(transparent)] pub struct G2(blst_p2);`
  - Represents a point on the BLS12-381 G2 curve, wrapping the `blst_p2` type.
  - G2 points are larger (compressed to 96 bytes, as per `G2_ELEMENT_BYTE_LENGTH`) due to the extension field \( \mathbb{F}_{p^2} \).

- **When Used**:
  - **Signatures**: In the standard BLS12-381 scheme (used in the provided code), signatures are G2 points. A signature is computed as \( \sigma = sk \cdot H(m) \), where \( H(m) \) is the message hashed to G2.
  - **Hashed Messages**: Messages are typically hashed to G2 for signing (using `G2_MESSAGE`).
  - **Proof of Possession**: The PoP for a G1 public key is often a G2 signature, created by hashing the public key to G2 and signing it.
  - **Verification**: In signature verification, a G2 point (signature or hashed message) is paired with a G1 point (public key) to produce a GT element.

#### 6. **G2_ELEMENT_BYTE_LENGTH: usize = 96**
- **Definition**: Specifies that a compressed G2 point is encoded as 96 bytes.
- **Why**: G2 points require more space due to the extension field, but compression reduces the size (similar to G1).
- **When Used**: During serialization/deserialization of G2 points (e.g., signatures or hashed messages) for storage or transmission.

#### 7. **G2_MESSAGE: DST = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_"**
- **Definition**: A DST for hashing messages to G2 points, using the `POP` scheme.
- **Purpose**: Ensures messages hashed to G2 are distinct from other contexts, used in the standard BLS signature scheme.
- **When Used**:
  - **Message Signing**: In the provided code (e.g., `Bls12381::sign`), messages are hashed to G2 using this DST: \( H(m) = \text{hash_to_g2}(m, \text{G2_MESSAGE}) \). The signature is then \( \sigma = sk \cdot H(m) \).
  - **Context**: This is the primary DST for signing messages in the standard BLS scheme (public keys in G1, signatures in G2), as used in the `verify_aggregated_signature` function.
  - Example: For a message \( m \), the signer computes \( H(m) \) using `G2_MESSAGE` and signs it to produce a G2 signature.

#### 8. **G2_PROOF_OF_POSSESSION: DST = b"BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_"**
- **Definition**: A DST for hashing a proof of possession (typically a compressed G1 point, i.e., a public key) to a G2 point.
- **Purpose**: Used to create a PoP by hashing a public key to G2, which is then signed to prove ownership of the private key.
- **When Used**:
  - **Proof of Possession**: To generate a PoP for a public key \( PK \) (G1):
    1. Hash \( PK \) to G2 using `G2_PROOF_OF_POSSESSION`: \( H(PK) = \text{hash_to_g2}(PK, \text{G2_PROOF_OF_POSSESSION}) \).
    2. Sign \( H(PK) \) with the private key: \( \sigma_{PoP} = sk \cdot H(PK) \).
    3. The PoP (\( \sigma_{PoP} \), a G2 point) is sent alongside the public key to prove the signer controls the private key.
  - **Verification**: To verify a PoP, the verifier hashes the public key to G2 using `G2_PROOF_OF_POSSESSION` and checks the signature: \( e(PK, H(PK)) = e(G_1, \sigma_{PoP}) \).
  - **Context**: Essential in aggregated signatures to prevent rogue key attacks, where an attacker could craft a malicious public key to manipulate the aggregated signature.

#### 9. **GT (blst_fp12)**
- **Definition**: `#[derive(Debug, Clone, Copy, Eq, PartialEq)] pub struct GT(blst_fp12);`
  - Represents an element in the target group \( \mathbb{F}_{p^{12}} \), the result of a pairing operation.
- **When Used**:
  - **Signature Verification**: The GT group is used in the pairing operation to verify signatures. For a single signature:
    \[
    e(PK, H(m)) = e(G_1, \sigma)
    \]
    where \( e \) is the pairing function, \( PK \) is the public key (G1), \( H(m) \) is the hashed message (G2), and \( \sigma \) is the signature (G2). Both sides produce GT elements, which are compared for equality.
  - **Aggregated Signature Verification**: For aggregated signatures, the pairing check is:
    \[
    e(PK_{agg}, H(m)) = e(G_1, \sigma_{agg})
    \]
    or, for distinct messages:
    \[
    \prod e(PK_i, H(m_i)) = e(G_1, \sigma_{agg})
    \]
    where \( PK_{agg} \) and \( \sigma_{agg} \) are aggregated public keys and signatures.
  - **Proof of Possession Verification**: When verifying a PoP, the pairing check produces GT elements: \( e(PK, H(PK)) = e(G_1, \sigma_{PoP}) \).

### When Each Type and DST is Used in Relation to Each Other

#### **Standard BLS Signature (Single Signature)**
- **Process**:
  1. **Message Hashing**: A message \( m \) is hashed to G2 using `G2_MESSAGE`: \( H(m) = \text{hash_to_g2}(m, \text{G2_MESSAGE}) \).
  2. **Signing**: The signer computes the signature: \( \sigma = sk \cdot H(m) \), where \( \sigma \) is a G2 point.
  3. **Verification**: The verifier checks:
     \[
     e(PK, H(m)) = e(G_1, \sigma)
     \]
     - \( PK \) (G1): The public key.
     - \( H(m) \) (G2): The message hashed with `G2_MESSAGE`.
     - \( \sigma \) (G2): The signature.
     - Both sides produce GT elements.
- **DSTs Used**:
  - `G2_MESSAGE`: For hashing the message to G2.
  - `G1_MESSAGE`: Not used unless the signature scheme swaps groups (signatures in G1, public keys in G2).
- **Types**:
  - G1: Public key.
  - G2: Hashed message and signature.
  - GT: Result of pairing for verification.

#### **Aggregated BLS Signature**
- **Process**:
  1. **Message Hashing**: Each signer hashes the message (or same message) to G2 using `G2_MESSAGE`.
  2. **Signing**: Each signer produces a signature \( \sigma_i = sk_i \cdot H(m) \) (G2).
  3. **Aggregation**:
     - Public keys (G1) are aggregated: \( PK_{agg} = \sum PK_i \), using `G1::msm` with unit scalars.
     - Signatures (G2) are aggregated: \( \sigma_{agg} = \sum \sigma_i \), using `G2::msm` with unit scalars.
  4. **Verification**: Assuming all signed the same message:
     \[
     e(PK_{agg}, H(m)) = e(G_1, \sigma_{agg})
     \]
     - \( PK_{agg} \) (G1): Aggregated public key.
     - \( H(m) \) (G2): Message hashed with `G2_MESSAGE`.
     - \( \sigma_{agg} \) (G2): Aggregated signature.
     - Both sides produce GT elements.
- **DSTs Used**:
  - `G2_MESSAGE`: For hashing messages to G2.
  - `G1_MESSAGE`: Not used unless the scheme is reversed.
- **Types**:
  - G1: Individual and aggregated public keys.
  - G2: Hashed messages and signatures (individual and aggregated).
  - GT: For pairing-based verification.

#### **Proof of Possession (PoP)**
- **Process**:
  1. **PoP Generation**:
     - A signer with private key \( sk \) and public key \( PK \) (G1) hashes \( PK \) to G2 using `G2_PROOF_OF_POSSESSION`: \( H(PK) = \text{hash_to_g2}(PK, \text{G2_PROOF_OF_POSSESSION}) \).
     - Signs \( H(PK) \): \( \sigma_{PoP} = sk \cdot H(PK) \) (G2).
  2. **PoP Verification**:
     - The verifier re-hashes \( PK \) to G2 using `G2_PROOF_OF_POSSESSION`.
     - Checks: \( e(PK, H(PK)) = e(G_1, \sigma_{PoP}) \).
     - Both sides produce GT elements.
  3. **Context**: PoP is sent with the public key in aggregated signature schemes to prove the signer controls \( sk \), preventing rogue key attacks.
- **DSTs Used**:
  - `G2_PROOF_OF_POSSESSION`: For hashing the public key to G2 during PoP generation and verification.
  - `G1_PROOF_OF_POSSESSION`: Used if the PoP scheme involves hashing to G1 (e.g., if signatures are in G1), but this is less common in the standard scheme.
- **Types**:
  - G1: Public key being proved.
  - G2: Hashed public key and PoP signature.
  - GT: For pairing-based PoP verification.

#### **Relation Between G1 and G2 in PoP and Signatures**
- **Standard Signature**:
  - G1: Public key.
  - G2: Message hash (`G2_MESSAGE`) and signature.
  - GT: Verification result.
- **PoP**:
  - G1: Public key to be hashed (to G2 using `G2_PROOF_OF_POSSESSION`).
  - G2: Hashed public key and PoP signature.
  - GT: Verification result.
- **Swapped Scheme (Rare)**:
  - If signatures are in G1 and public keys in G2 (not used in your code but supported by the DSTs):
    - G2: Public key.
    - G1: Message hash (`G1_MESSAGE`) and signature.
    - GT: Verification result.
    - PoP would use `G1_PROOF_OF_POSSESSION` to hash the G2 public key to G1.

#### **Why Both G1 and G2 DSTs?**
- The library supports both standard (public keys in G1, signatures in G2) and swapped (public keys in G2, signatures in G1) BLS schemes, as per the IETF BLS standard.
- `G1_MESSAGE` and `G2_MESSAGE` allow hashing messages to either group, depending on the scheme.
- `G1_PROOF_OF_POSSESSION` and `G2_PROOF_OF_POSSESSION` support PoP in both schemes, ensuring flexibility.
- In your code (`verify_aggregated_signature`), the standard scheme is used (G1 public keys, G2 signatures), so `G2_MESSAGE` is used for messages, and `G2_PROOF_OF_POSSESSION` would be used if PoP were implemented.

### Clarifying the Confusion
- **Proof of Possession vs. Message DSTs**:
  - **Message DSTs (`G1_MESSAGE`, `G2_MESSAGE`)**: Used when signing or verifying messages. `G2_MESSAGE` is used in your code because signatures are G2 points.
  - **PoP DSTs (`G1_PROOF_OF_POSSESSION`, `G2_PROOF_OF_POSSESSION`)**: Used when proving ownership of a private key. For a G1 public key, `G2_PROOF_OF_POSSESSION` hashes it to G2 for signing. `G1_PROOF_OF_POSSESSION` is for the swapped scheme.
- **When They’re Used Together**:
  - In aggregated signatures (like in your code), each public key should be accompanied by a PoP:
    - Generate PoP: Hash \( PK \) (G1) to G2 with `G2_PROOF_OF_POSSESSION`, sign it.
    - Verify PoP before aggregating public keys or signatures.
    - Sign message: Hash \( m \) to G2 with `G2_MESSAGE`, sign it.
    - Verify aggregated signature: Use `G2_MESSAGE` for the message hash.
- **Byzantine Environment**: The `POP` scheme is used to prevent rogue key attacks, where an attacker submits a malicious public key to manipulate aggregated signatures. PoP ensures each public key is legitimate.

### Example in Your Code
In the `verify_aggregated_signature` function:
- **G1**: Public keys (`public_keys: &[G1]`) are aggregated using `G1::msm`.
- **G2**: Signatures are G2 points (returned by `signer.sign`), hashed with `G2_MESSAGE`. They’re aggregated using `G2::msm`.
- **GT**: Implicitly used in `Bls12381::verify_aggregate` for pairing checks.
- **DSTs**:
  - `G2_MESSAGE`: Used in `signer.sign` to hash the message to G2.
  - `G1_MESSAGE`: Not used (would be for G1 signatures).
  - `G2_PROOF_OF_POSSESSION`: Not used in the function but would be if PoP were verified for each public key.
  - `G1_PROOF_OF_POSSESSION`: Not used (would be for G1 PoP signatures).

### Summary Table
| Type/Constant | Group | Role | When Used | DST Usage |
|---------------|-------|------|-----------|-----------|
| `G1` | G1 | Public keys, aggregated public keys | Signing, verification, PoP | `G1_MESSAGE` (message hashing in swapped scheme), `G1_PROOF_OF_POSSESSION` (PoP for G2 public keys) |
| `G2` | G2 | Signatures, hashed messages | Signing, verification, PoP | `G2_MESSAGE` (message hashing in standard scheme), `G2_PROOF_OF_POSSESSION` (PoP for G1 public keys) |
| `GT` | \( \mathbb{F}_{p^{12}} \) | Pairing result | Verification (single or aggregated signatures, PoP) | N/A |
| `G1_MESSAGE` | - | Hash messages to G1 | Signing/verifying in swapped scheme | Hashing messages for G1 signatures |
| `G2_MESSAGE` | - | Hash messages to G2 | Signing/verifying in standard scheme | Hashing messages for G2 signatures (used in your code) |
| `G1_PROOF_OF_POSSESSION` | - | Hash PoP to G1 | PoP for G2 public keys | Hashing G2 public keys for PoP |
| `G2_PROOF_OF_POSSESSION` | - | Hash PoP to G2 | PoP for G1 public keys | Hashing G1 public keys for PoP |

### Recommendations
- **PoP in Your Code**: Your `verify_aggregated_signature` function doesn’t verify PoP for public keys. To make it secure in a Byzantine environment, add PoP verification using `G2_PROOF_OF_POSSESSION` before aggregating public keys.
- **Learning Next Steps**: Experiment with PoP by adding a function to generate and verify PoPs for each public key, using `G2_PROOF_OF_POSSESSION`. This would clarify how PoP integrates with aggregated signatures.
- **Swapped Scheme**: If you want to explore the swapped scheme (G2 public keys, G1 signatures), use `G1_MESSAGE` for message hashing and `G1_PROOF_OF_POSSESSION` for PoP.

Let me know if you want to add PoP verification to your code or need further clarification on any aspect!